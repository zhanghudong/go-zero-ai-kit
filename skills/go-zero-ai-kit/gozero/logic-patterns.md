# Logic 业务模式库（严格版）

## 模式1：查询 + 返回
- 步骤1：查询数据
- 步骤2：判断不存在/非法状态
- 步骤3：拼装响应
- 注意：分页默认值来自 .api；`pageSize` 只做上限裁剪

## 模式2：状态迁移
- 步骤1：查询当前状态
- 步骤2：校验状态可迁移
- 步骤3：更新状态（注明原因）
- 步骤4：记录审计/日志

## 模式3：创建/写入
- 步骤1：检查幂等（如有业务唯一键）
- 步骤2：写入主表
- 步骤3：写入关联表/日志
- 步骤4：返回主键

## 模式4：外部调用
- 步骤1：组装请求
- 步骤2：调用外部服务
- 步骤3：处理异常/超时
- 步骤4：落库或返回

## 模式5：更新（按字段选择性更新）
- 步骤1：查询当前状态
- 步骤2：对非空字段构建更新内容
- 步骤3：执行更新
- 步骤4：返回结果

## 模式6：列表分页查询
- 步骤1：构建 `RowBuilder` 与 `CountBuilder("*")`
- 步骤2：按条件追加 where（字段统一加反引号）
- 步骤3：先查总数，再查分页数据

## 模式7：异步任务（主流程快速返回）
- 步骤1：主流程完成核心落库并返回响应
- 步骤2：复制必要入参，避免共享可变对象
- 步骤3：使用新 context 保留 trace，脱离请求 cancel
- 步骤4：设置任务超时并使用 `threading.GoSafeCtx` 执行
- 步骤5：异步失败只记录错误日志，不影响主流程结果
- 注意：异步任务内禁止依赖已取消的请求上下文

## 模式8：分布式锁（按业务键串行）
- 步骤1：按业务主键构建 lock key（如 `orderId`）
- 步骤2：创建 redis lock 并设置过期时间
- 步骤3：获取锁失败时区分系统异常与锁竞争
- 步骤4：成功后执行临界区逻辑并 `defer` 释放锁
- 步骤5：释放锁失败记录告警日志，不吞掉业务错误
- 注意：临界区内状态迁移应使用 CAS；`affected == 0` 视为并发命中并幂等退出
